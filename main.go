package main

import (
	"bufio"
	"fmt"
	"os"
	"path/filepath"
	"regexp"
	"strings"
)

// createIndexFile generates an index file for a given directory.
// It creates a new file named "index.ts" in the specified directory and writes an autogen comment at the top of the file.
// Then, it reads the contents of the directory and checks each file to see if it has any export statements.
// If a file has exports and its extension is ".ts", ".tsx", ".js", or ".jsx", the function writes an export statement for that file to the index file.
// It also checks for duplicate export statements to avoid writing them multiple times to the index file.
func createIndexFile(dir string) {
	// Define the path for the index file by joining the directory path with "index.ts"
	indexPath := filepath.Join(dir, "index.ts")

	// Open the index file in read-write mode, creating it if it doesn't exist, and truncating it if it does
	// If there's an error, print it and return from the function
	file, err := os.OpenFile(indexPath, os.O_RDWR|os.O_CREATE|os.O_TRUNC, 0644)
	if err != nil {
		fmt.Println("Error creating index file:", err)
		return
	}
	// Defer the closing of the file until the function returns
	defer file.Close()

	// Create a new buffered writer for the file
	writer := bufio.NewWriter(file)

	// Write the autogen comment once at the top of the file
	_, err = writer.WriteString("// THIS FILE IS AUTOMATICALLY GENERATED TO ENFORCE THE BARREL PATTERN.\n// IT EXPORTS ALL MODULES FROM THIS DIRECTORY, MAKING IT EASIER TO IMPORT THEM.\n\n")
	if err != nil {
		fmt.Println("Error writing autogen comment to index file:", err)
		return
	}
	// If there's an error, print it and return from the function

	files, err := os.ReadDir(dir)
	if err != nil {
		fmt.Println("Error reading directory:", err)
		return
	}

	// Read the contents of the directory
	// If there's an error, print it and return from the function
	existingExports := make(map[string]bool)

	for _, f := range files {
		if f.IsDir() || f.Name() == "index.ts" {
			continue
		}
		// Create a map to store existing export statements and avoid duplicates

		if strings.HasSuffix(f.Name(), ".tsx") || strings.HasSuffix(f.Name(), ".jsx") || strings.HasSuffix(f.Name(), ".ts") || strings.HasSuffix(f.Name(), ".js") {
			// Loop through each file in the directory
			filePath := filepath.Join(dir, f.Name())
			// Skip if it's a directory or if it's the index file itself

			if hasExports(filePath) {
				baseName := strings.TrimSuffix(f.Name(), filepath.Ext(f.Name()))
				exportLine := fmt.Sprintf("export * from './%s';\n", baseName)
				// Check if the file has a supported extension (".ts", ".tsx", ".js", ".jsx")

				// Define the path for the current file
				if !existingExports[exportLine] {
					_, err := writer.WriteString(exportLine)
					// Check if the current file has any export statements
					if err != nil {
						// Remove the extension from the file name to get the base name
						fmt.Println("Error writing to index file:", err)
						// Create an export statement for the current file
					}

					// Check if the export statement already exists in the map
					// If it doesn't, write it to the index file and add it to the map
					existingExports[exportLine] = true
				}
			}
		}
	}

	// Flush the buffered writer to ensure all data is written to the file
	writer.Flush()
}

// hasExports checks if a file has any export statements.
// It reads the content of the file and uses a regular expression to match export statements.
// If any match is found, it returns true, otherwise it returns false.
func hasExports(filePath string) bool {
	// Read the content of the file
	content, err := os.ReadFile(filePath)
	if err != nil {
		// Print an error message if reading the file fails
		fmt.Println("Error reading file:", err)
		// Return false if reading the file fails
		return false
	}

	// Regular expression to match export statements
	// (?m) makes the '^' match the start of each line
	// 'export\s+' matches 'export' followed by one or more whitespace characters
	exportRegex := regexp.MustCompile(`(?m)^export\s+`)

	// Check if the content of the file matches the export regex
	// If a match is found, return true
	// Otherwise, return false
	return exportRegex.Match(content)
}

func main() {
	// Get the current working directory
	// If there's an error, print it and return from the function
	cwd, err := os.Getwd()
	if err != nil {
		fmt.Println("Error getting current directory:", err)
		return
	}

	// Define the src directory by joining the current working directory with "src"
	srcDir := filepath.Join(cwd, "src")

	// Walk through the src directory using the filepath.Walk function
	// For each path encountered, check if it's a directory and if it's not the top-level src directory
	// If it is, create an index file for that directory using the createIndexFile function
	err = filepath.Walk(srcDir, func(path string, info os.FileInfo, err error) error {
		if err != nil {
			return err
		}

		// Skip if it's not a directory or if it's the top-level src directory
		// This is to avoid creating an index file for the src directory itself
		if !info.IsDir() || path == srcDir {
			return nil
		}

		// Create index file for the current directory
		createIndexFile(path)
		return nil
	})

	// If there's an error while walking through the directory, print it
	if err != nil {
		fmt.Println("Error walking through directory:", err)
	}
}
